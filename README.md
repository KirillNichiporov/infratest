# Запуск инфраструктуры

1. Клонировать репозиторий

```bash

git clone https://github.com/KirillNichiporov/infratest.git

```
   
2. Выполнить следующие команды для того,чтобы залить изменения в будущем на докальный гит

```bash

git remote add infra http://localhost:8000/root/infratest.git

```

3. Запустить инфраструктуру с помощью команды:

```bash

docker-compose up -d 

```
### Состав инфраструктуры

1. GitLab
2. GitLab Runner
3. Registry
4. Staging(условный)

Пароль к root gitlab записан в .env, а так же токен к раннеру, его добавляю "насильно" через переменные окружения для простоты использования теста. Хранилище образов добавлено для непосредственного деплоя и использования образа из него, потому что считаю подобный метод верным и более интересным чем лить напрямую. Staging представляет и себя просто контейнер Dind для запуска на нем приложения.

# Запуск Pipeline

1. Перед тем как залить проект на локальный GitLab необходимо добавить в скрипт notify.sh ваши chat_id и telegram_bot_token для отправки уведомлений при успешном или неуспешном завершении пайплайна.
2. Выполнить команду

```bash

git push infra main

```

После того как проект будет залит автоматически запустится пайплайн, который проверит код проекта, соберет образ, зальет его в хранилище, затем развернет на условном staging  и проведет тест, а результат выведет в лог stage. При завершении придет уведомление об успехе.

# Некоторые пояснения по файлам проекта

### Docker-compose

Файл стандартный, излишне непонятных вещей там нет, networks и volume не прописывал особо, посчитал ненужным.

### Notify

Скрипт,для отправки уведомлений, вообще можно было непосредственно в пайплайне прописать, но зачем излишки. В GitLab уже есть конкретная настройка для уведомлений, так что настраивал бы ее готовыми инструментами и не залазил в скрипты(но не в случае с тестовым заданием).

### Файлы проекта
Само приложение состоит из небольшого сервера написанного на python  с помощью Flask, принимает 2 метода, один как хелсчек, а второй возвращает преданный аргумент, если передали.

Dcokerfile также простой, устанавливает Flask,копирует файл с кодом и запускает.

### .gitlab-ci.yml

Пайплайн разделен на этапы, начинается с линтера, использовал flake8, так же разрешил этому этапу закончиться с ошибкой(в любом случае линтер что-то да найдет), чтобы пошло выполнение далее.
Далее сборка образа и отправка его в хранилище образов, на этом этапе их можно совмещать, но при продакшене я бы разделял и между ними добавлял сканирование контейнеров на уязвимости, тут это не имеет смысла.
Для деплоя используется ранее развернутый staging и приложение запускается с помощью использования контекста, котрый добавился скриптом в пайплайне. Так же в логах можно будет увидет вывод списка запущенных контейнерах или зайти в staging и посмотреть внутри него.
Тест осуществляется в самом конце, он дергает хелсчек прилжения и возвращает ответ 200 ОК(можно увидеть в логе пайплайна). Затем отправка уведомления об успехе.
Если какой-то из этапов прерывается ошибкой, то отправляется уведомление об неудаче.























